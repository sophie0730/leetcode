## Heap

Heap是完全二元樹，指的是一棵二元樹到最後一層之前，由左往右都是填滿的狀態，只有最右側的最後一個節點空缺。
根據大小排列的不同，可分為min heap和max heap。
min heap代表對應的父節點永遠小於子節點，因此根節點永遠為最小值。max heap則相反

備註：但這種實作我們只能確保根節點為全部陣列的最小值，沒有辦法讓整個heap是由小排到大的

在Python中我們可以透過heapq模組來操作heap這個完全二元樹，並使用heappush, heappop等函式操作。


## 解題思路
由於題目只是為了找出第k大的數字，因此不需要將整個陣列進行排序。
這時候我們可以使用min heap，並在heap中留下k個節點，這些節點的根節點就會是第k大的數字。

## 時間複雜度：O((m+n) log k)

### add()
heap本身添加元素的時間複雜度為O(logk), k為heap中的節點數量

### __init__
對陣列中的每個元素調用add(), 而add()的時間複雜度為O(log k)
所以時間複雜度為O(n log k), n 為陣列長度

最後，由於陣列在初始化為heap時的時間複雜度為O(m log k), m為陣列長度
因此最後的時間複雜度為O((m+n) log k)

## 空間複雜度
heap只包含前k大的節點，因此空間複雜度為O(k)

